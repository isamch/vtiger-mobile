import { useEffect, useState, useRef } from "react"
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  ActivityIndicator,
  TouchableOpacity,
  StatusBar,
  Dimensions,
  TextInput,
  Switch,
  Alert,
  Modal,
  FlatList,
  Platform,
} from "react-native"
import Header from "../../components/Header"
import Footer from "../../components/Footer"
import Icon from "react-native-vector-icons/MaterialIcons"
import { getModuleFields } from "../../services/api/modules/getFieldsAPI"
import { createModuleRecord } from "../../services/api/modules/crud/storeAPI"
import AsyncStorage from '@react-native-async-storage/async-storage'
import DateTimePicker from '@react-native-community/datetimepicker'
import { convertUTCToLocal, convertLocalToUTC, formatDate, convertDateTimeToUTC } from "../../utils/dateTimeUtils"

const { width } = Dimensions.get("window")

const CreateScreen = ({ route, navigation }) => {
  const { moduleName } = route.params
  
  // Add array of fields to hide
  const hiddenFields = [
    'createdtime',
    'modifiedtime',
    'created_user_id',
    'modifiedby',
    'source',
    'starred',
    'tags',
    'id'
  ]

  const [fields, setFields] = useState([])
  const [formData, setFormData] = useState({})
  const [loading, setLoading] = useState(true)
  const [saving, setSaving] = useState(false)
  const [error, setError] = useState(null)
  const [searchQuery, setSearchQuery] = useState("")
  const [validationErrors, setValidationErrors] = useState({})
  const [showPicklistModal, setShowPicklistModal] = useState(false)
  const [currentPicklistField, setCurrentPicklistField] = useState(null)
  const [showDatePicker, setShowDatePicker] = useState(false)
  const [showTimePicker, setShowTimePicker] = useState(false)
  const [currentDateField, setCurrentDateField] = useState(null)
  const [datePickerMode, setDatePickerMode] = useState('date')
  const [tempDateTime, setTempDateTime] = useState(new Date())
  
  const [userData, setUserData] = useState(null)

  const scrollViewRef = useRef(null);
  const fieldRefs = useRef({});

  const fetchFields = async () => {
    try {
      setLoading(true)
      setError(null)
      const response = await getModuleFields(moduleName)
      const fieldsData = response?.fields || []
      
      // Transform the fields data to match the expected format
      const transformedFields = fieldsData.map(field => ({
        ...field,
        type: field.type.name,
        picklistValues: field.type.picklistValues || [],
        refersTo: field.type.refersTo,
        format: field.type.format
      }))
      
      setFields(transformedFields)

      // Initialize form data with empty values
      const initialFormData = {}
      transformedFields.forEach((field) => {
        initialFormData[field.name] = field.default || ""
      })
      setFormData(initialFormData)
    } catch (e) {
      setError(e.message)
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => {
    fetchFields()
  }, [moduleName])

  const getFieldIcon = (fieldType) => {
    const iconMap = {
      email: "email",
      phone: "phone",
      date: "event",
      datetime: "schedule",
      boolean: "toggle-on",
      reference: "link",
      owner: "person",
      text: "description",
      string: "text-fields",
      picklist: "arrow-drop-down",
      image: "image",
      autogenerated: "autorenew"
    }
    return iconMap[fieldType] || "edit"
  }

  const validateField = (field, value) => {
    const errors = []

    if (field.mandatory && (!value || value.toString().trim() === "")) {
      errors.push(`${field.label} is required`)
    }

    if (value && field.type === "email") {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
      if (!emailRegex.test(value)) {
        errors.push("Please enter a valid email address")
      }
    }

    if (value && field.type === "phone") {
      const phoneRegex = /^[\d\s\-+$$$$]+$/
      if (!phoneRegex.test(value)) {
        errors.push("Please enter a valid phone number")
      }
    }

    return errors
  }

  const validateForm = () => {
    const errors = {}
    let isValid = true

    fields.forEach((field) => {
      const fieldErrors = validateField(field, formData[field.name])
      if (fieldErrors.length > 0) {
        errors[field.name] = fieldErrors
        isValid = false
      }
    })

    setValidationErrors(errors)
    return isValid
  }

  const handleCreate = async () => {
    
    if (!validateForm()) {
      // Find the first field with an error
      const firstErrorField = Object.keys(validationErrors)[0];
      if (firstErrorField && fieldRefs.current[firstErrorField] && scrollViewRef.current) {
        // Scroll to the field with error
        fieldRefs.current[firstErrorField].measure((x, y, width, height, pageX, pageY) => {
          scrollViewRef.current.scrollTo({ y: pageY - 100, animated: true });
        });
      }
      return;
    }

    try {
      setSaving(true)

      // Get current user data for assigned_user_id field
      const userData = JSON.parse(await AsyncStorage.getItem('userData'));
      setUserData(userData);

      // Prepare fields data
      const fieldsData = { ...formData }
      
      // Set assigned_user_id to current user if not specified
      if (userData && userData.userId && !fieldsData.modifiedby) {
        fieldsData.modifiedby = userData.userId;
      }

      // Call the create API
      const recordId = await createModuleRecord(moduleName, fieldsData)

      Alert.alert("Success", "Record created successfully!", [
        {
          text: "View Record",
          onPress: () => navigation.navigate('ViewScreen', { moduleName, recordId }),
        },
      ])
    } catch (e) {
      Alert.alert("Error", `Failed to create: ${e.message}`)
    } finally {
      setSaving(false)
    }
  }

  const updateFieldValue = (fieldname, value) => {
    setFormData((prev) => ({
      ...prev,
      [fieldname]: value,
    }))

    // Clear validation error for this field
    if (validationErrors[fieldname]) {
      setValidationErrors((prev) => {
        const newErrors = { ...prev }
        delete newErrors[fieldname]
        return newErrors
      })
    }
  }

  const formatTime = (date) => {
    const hours = String(date.getHours()).padStart(2, '0')
    const minutes = String(date.getMinutes()).padStart(2, '0')
    const seconds = String(date.getSeconds()).padStart(2, '0')
    return `${hours}:${minutes}:${seconds}`
  }

  const formatDate = (date, includeTime = false) => {
    if (!date) return ''
    const d = new Date(date)
    const year = d.getFullYear()
    const month = String(d.getMonth() + 1).padStart(2, '0')
    const day = String(d.getDate()).padStart(2, '0')
    if (!includeTime) {
      return `${year}-${month}-${day}`
    }
    return `${year}-${month}-${day} ${formatTime(d)}`
  }

  const onDateChange = (event, selectedDate) => {
    if (Platform.OS === 'android') {
      setShowDatePicker(false)
      setShowTimePicker(false)
    }
    
    if (event.type === 'dismissed') {
      setShowDatePicker(false)
      setShowTimePicker(false)
      return
    }

    if (selectedDate) {
      setTempDateTime(selectedDate)
      
      if (currentDateField?.type === 'datetime' && datePickerMode === 'date' && Platform.OS === 'android') {
        setDatePickerMode('time')
        setShowTimePicker(true)
        return
      }

      // Handle different field types
      if (currentDateField?.type === 'time') {
        // Convert the selected local time to UTC before saving
        const utcTime = convertLocalToUTC(selectedDate)
        updateFieldValue(currentDateField?.name, utcTime)
      } else if (currentDateField?.type === 'datetime') {
        if (datePickerMode === 'time' || Platform.OS === 'ios') {
          // Convert the entire datetime to UTC
          const utcDateTime = convertDateTimeToUTC(selectedDate)
          updateFieldValue(currentDateField?.name, utcDateTime)
        }
      } else if (currentDateField?.type === 'date') {
        // For date-only fields, use local date format
        const formattedDate = formatDate(selectedDate)
        updateFieldValue(currentDateField?.name, formattedDate)
      }
    }
    
    if (Platform.OS === 'ios') {
      setShowDatePicker(false)
      setShowTimePicker(false)
    }
  }

  const renderInput = (field) => {
    const value = formData[field.name] || ""
    const hasError = validationErrors[field.name]

    switch (field.type) {
      case "boolean":
        return (
          <View style={styles.switchContainer}>
            <Switch
              value={value === "1" || value === true || value === "yes"}
              onValueChange={(newValue) => updateFieldValue(field.name, newValue ? "1" : "0")}
              trackColor={{ false: "#e2e8f0", true: "#6366f1" }}
              thumbColor={value === "1" || value === true || value === "yes" ? "#ffffff" : "#f1f5f9"}
            />
            <Text style={styles.switchLabel}>
              {value === "1" || value === true || value === "yes" ? "Yes" : "No"}
            </Text>
          </View>
        )

      case "picklist":
        return (
          <TouchableOpacity
            style={[styles.picklistButton, hasError && styles.inputError]}
            onPress={() => {
              setCurrentPicklistField(field)
              setShowPicklistModal(true)
            }}
          >
            <Text style={[styles.picklistText, !value && styles.placeholderText]}>
              {value || "Select an option"}
            </Text>
            <Icon name="arrow-drop-down" size={24} color="#64748b" />
          </TouchableOpacity>
        )

      case "text":
        return (
          <TextInput
            style={[styles.textArea, hasError && styles.inputError]}
            value={value}
            onChangeText={(text) => updateFieldValue(field.name, text)}
            placeholder={`Enter ${field.label.toLowerCase()}`}
            placeholderTextColor="#94a3b8"
            multiline
            numberOfLines={4}
            textAlignVertical="top"
          />
        )

      case "date":
        return (
          <TouchableOpacity
            style={[styles.picklistButton, hasError && styles.inputError]}
            onPress={() => {
              setCurrentDateField(field)
              setDatePickerMode('date')
              setTempDateTime(value ? new Date(value) : new Date())
              setShowDatePicker(true)
            }}
          >
            <Text style={[styles.picklistText, !value && styles.placeholderText]}>
              {value || 'Select date'}
            </Text>
            <Icon name="event" size={24} color="#64748b" />
          </TouchableOpacity>
        )

      case "datetime":
        const [dateValue, timeValue] = value ? value.split(' ') : ['', '']
        return (
          <View>
            <TouchableOpacity
              style={[styles.picklistButton, hasError && styles.inputError, { marginBottom: 8 }]}
              onPress={() => {
                setCurrentDateField(field)
                setDatePickerMode('date')
                setTempDateTime(value ? new Date(value) : new Date())
                setShowDatePicker(true)
              }}
            >
              <Text style={[styles.picklistText, !dateValue && styles.placeholderText]}>
                {dateValue || 'Select date'}
              </Text>
              <Icon name="event" size={24} color="#64748b" />
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.picklistButton, hasError && styles.inputError]}
              onPress={() => {
                setCurrentDateField(field)
                setDatePickerMode('time')
                setTempDateTime(value ? new Date(value) : new Date())
                setShowTimePicker(true)
              }}
            >
              <Text style={[styles.picklistText, !timeValue && styles.placeholderText]}>
                {timeValue ? convertUTCToLocal(timeValue) : 'Select time'}
              </Text>
              <Icon name="schedule" size={24} color="#64748b" />
            </TouchableOpacity>
          </View>
        )

      case "email":
        return (
          <TextInput
            style={[styles.input, hasError && styles.inputError]}
            value={value}
            onChangeText={(text) => updateFieldValue(field.name, text)}
            placeholder={`Enter ${field.label.toLowerCase()}`}
            placeholderTextColor="#94a3b8"
            keyboardType="email-address"
            autoCapitalize="none"
            autoCorrect={false}
          />
        )

      case "phone":
        return (
          <TextInput
            style={[styles.input, hasError && styles.inputError]}
            value={value}
            onChangeText={(text) => updateFieldValue(field.name, text)}
            placeholder={`Enter ${field.label.toLowerCase()}`}
            placeholderTextColor="#94a3b8"
            keyboardType="phone-pad"
          />
        )

      case "reference":
        return (
          <TouchableOpacity
            style={[styles.picklistButton, hasError && styles.inputError]}
            onPress={() => {
              // Handle reference field selection
              Alert.alert("Coming Soon", "Reference field selection will be implemented soon")
            }}
          >
            <Text style={[styles.picklistText, !value && styles.placeholderText]}>
              {value || `Select ${field.label}`}
            </Text>
            <Icon name="arrow-drop-down" size={24} color="#64748b" />
          </TouchableOpacity>
        )

      case "owner":
        return (
          <TouchableOpacity
            style={[styles.picklistButton, hasError && styles.inputError]}
            onPress={() => {
              setCurrentPicklistField(field)
              setShowPicklistModal(true)
            }}
          >
            <Text style={[styles.picklistText, !value && styles.placeholderText]}>
              {value ? field.picklistValues?.find(item => item.value === value)?.label || value : "Select Owner"}
            </Text>
            <Icon name="arrow-drop-down" size={24} color="#64748b" />
          </TouchableOpacity>
        )

      case "image":
        return (
          <TouchableOpacity
            style={[styles.picklistButton, hasError && styles.inputError]}
            onPress={() => {
              // Handle image upload
              Alert.alert("Coming Soon", "Image upload will be implemented soon")
            }}
          >
            <Text style={[styles.picklistText, !value && styles.placeholderText]}>
              {value || "Select Image"}
            </Text>
            <Icon name="image" size={24} color="#64748b" />
          </TouchableOpacity>
        )

      case "autogenerated":
        return (
          <View style={[styles.input, { backgroundColor: "#f1f5f9" }]}>
            <Text style={[styles.picklistText, { color: "#64748b" }]}>
              Auto-generated
            </Text>
          </View>
        )

      case "time":
        return (
          <TouchableOpacity
            style={[styles.picklistButton, hasError && styles.inputError]}
            onPress={() => {
              setCurrentDateField(field)
              setDatePickerMode('time')
              
              // Create a Date object with the local time
              let timeToUse = new Date()
              if (value) {
                // Convert UTC time to local Date object
                const [hours, minutes, seconds] = value.split(':')
                timeToUse = new Date()
                timeToUse.setUTCHours(parseInt(hours, 10))
                timeToUse.setUTCMinutes(parseInt(minutes, 10))
                timeToUse.setUTCSeconds(parseInt(seconds, 10))
              }
              
              setTempDateTime(timeToUse)
              setShowTimePicker(true)
            }}
          >
            <Text style={[styles.picklistText, !value && styles.placeholderText]}>
              {value ? convertUTCToLocal(value) : 'Select time'}
            </Text>
            <Icon name="schedule" size={24} color="#64748b" />
          </TouchableOpacity>
        )

      default:
        return (
          <TextInput
            style={[styles.input, hasError && styles.inputError]}
            value={value}
            onChangeText={(text) => updateFieldValue(field.name, text)}
            placeholder={`Enter ${field.label.toLowerCase()}`}
            placeholderTextColor="#94a3b8"
            autoCapitalize="words"
            editable={field.editable !== false}
          />
        )
    }
  }

  const filteredFields = fields.filter((field) => {
    // First exclude hidden fields
    if (hiddenFields.includes(field.name)) {
      return false;
    }

    if (!searchQuery.trim()) return true

    const query = searchQuery.toLowerCase()
    const labelMatch = field.label?.toLowerCase().includes(query)
    const nameMatch = field.name?.toLowerCase().includes(query)

    return labelMatch || nameMatch
  })

  const renderFieldCard = (field, index) => {
    const hasError = validationErrors[field.name]

    return (
      <View 
        key={index} 
        style={[styles.fieldCard, hasError && styles.fieldCardError]}
        ref={ref => fieldRefs.current[field.name] = ref}
      >
        <View style={styles.fieldHeader}>
          <View style={styles.fieldIconContainer}>
            <Icon name={getFieldIcon(field.type)} size={18} color="#6366f1" />
          </View>
          <View style={styles.fieldInfo}>
            <Text style={styles.fieldLabel}>
              {field.label}
              {field.mandatory && <Text style={styles.requiredAsterisk}> *</Text>}
            </Text>
            {field.mandatory && (
              <View style={styles.mandatoryBadge}>
                <Text style={styles.mandatoryText}>Required</Text>
              </View>
            )}
          </View>
        </View>

        <View style={styles.fieldInputContainer}>{renderInput(field)}</View>

        {hasError && (
          <View style={styles.errorContainer}>
            <Icon name="error-outline" size={16} color="#ef4444" />
            <Text style={styles.errorText}>{hasError[0]}</Text>
          </View>
        )}
      </View>
    )
  }

  const renderSearchBar = () => (
    <View style={styles.searchContainer}>
      <View style={styles.searchInputContainer}>
        <Icon name="search" size={20} color="#64748b" style={styles.searchIcon} />
        <TextInput
          style={styles.searchInput}
          placeholder="Search fields..."
          placeholderTextColor="#94a3b8"
          value={searchQuery}
          onChangeText={setSearchQuery}
          autoCapitalize="none"
          autoCorrect={false}
        />
        {searchQuery.length > 0 && (
          <TouchableOpacity style={styles.clearButton} onPress={() => setSearchQuery("")}>
            <Icon name="clear" size={20} color="#64748b" />
          </TouchableOpacity>
        )}
      </View>
      {searchQuery.length > 0 && (
        <Text style={styles.searchResults}>
          {filteredFields.length} field{filteredFields.length !== 1 ? "s" : ""} found
        </Text>
      )}
    </View>
  )

  const renderContent = () => {
    if (loading) {
      return (
        <View style={styles.container}>
          {renderSearchBar()}
          <View style={styles.loaderContainer}>
            <View style={styles.loaderCard}>
              <ActivityIndicator size="large" color="#6366f1" />
              <Text style={styles.loaderText}>Loading form...</Text>
              <Text style={styles.loaderSubtext}>Please wait while we prepare the form</Text>
            </View>
          </View>
        </View>
      )
    }

    if (error) {
      return (
        <View style={styles.errorContainer}>
          <View style={styles.errorCard}>
            <View style={styles.errorIconContainer}>
              <Icon name="error-outline" size={48} color="#ef4444" />
            </View>
            <Text style={styles.errorTitle}>Something went wrong</Text>
            <Text style={styles.errorText}>{error}</Text>
            <TouchableOpacity style={styles.retryButton} onPress={() => fetchFields()}>
              <Icon name="refresh" size={20} color="#ffffff" />
              <Text style={styles.retryButtonText}>Try Again</Text>
            </TouchableOpacity>
          </View>
        </View>
      )
    }

    if (!fields || fields.length === 0) {
      return (
        <View style={styles.emptyStateContainer}>
          <View style={styles.emptyStateCard}>
            <View style={styles.emptyIconContainer}>
              <Icon name="edit-off" size={64} color="#d1d5db" />
            </View>
            <Text style={styles.emptyStateTitle}>No fields available</Text>
            <Text style={styles.emptyStateText}>
              Could not find any fields for this {moduleName.toLowerCase()} module.
            </Text>
          </View>
        </View>
      )
    }

    return (
      <ScrollView
        ref={scrollViewRef}
        style={styles.detailsContainer}
        showsVerticalScrollIndicator={false}
        contentContainerStyle={styles.scrollContent}
      >
        <View style={styles.statsContainer}>
          <View style={styles.statCard}>
            <Text style={styles.statNumber}>{filteredFields.length}</Text>
            <Text style={styles.statLabel}>Total Fields</Text>
          </View>
          <View style={styles.statCard}>
            <Text style={styles.statNumber}>{filteredFields.filter((f) => f.mandatory).length}</Text>
            <Text style={styles.statLabel}>Required</Text>
          </View>
          <View style={styles.statCard}>
            <Text style={styles.statNumber}>{Object.keys(validationErrors).length}</Text>
            <Text style={styles.statLabel}>Errors</Text>
          </View>
        </View>

        <View style={styles.fieldsContainer}>
          {filteredFields.length > 0 ? (
            filteredFields.map((field, index) => renderFieldCard(field, index))
          ) : (
            <View style={styles.noResultsContainer}>
              <Icon name="search-off" size={48} color="#d1d5db" />
              <Text style={styles.noResultsTitle}>No fields found</Text>
              <Text style={styles.noResultsText}>Try adjusting your search terms</Text>
            </View>
          )}
        </View>
      </ScrollView>
    )
  }

  const renderPicklistModal = () => {
    if (!currentPicklistField) return null;

    const options = currentPicklistField.picklistValues || [];

    return (
      <Modal
        visible={showPicklistModal}
        transparent={true}
        animationType="slide"
        onRequestClose={() => setShowPicklistModal(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>Select {currentPicklistField.label}</Text>
              <TouchableOpacity
                style={styles.modalCloseButton}
                onPress={() => setShowPicklistModal(false)}
              >
                <Icon name="close" size={24} color="#64748b" />
              </TouchableOpacity>
            </View>

            <FlatList
              data={options}
              keyExtractor={(item) => item.value}
              renderItem={({ item }) => (
                <TouchableOpacity
                  style={[
                    styles.optionItem,
                    formData[currentPicklistField.name] === item.value && styles.selectedOption,
                  ]}
                  onPress={() => {
                    updateFieldValue(currentPicklistField.name, item.value)
                    setShowPicklistModal(false)
                  }}
                >
                  <Text
                    style={[
                      styles.optionText,
                      formData[currentPicklistField.name] === item.value && styles.selectedOptionText,
                    ]}
                  >
                    {item.label}
                  </Text>
                  {formData[currentPicklistField.name] === item.value && (
                    <Icon name="check" size={20} color="#6366f1" />
                  )}
                </TouchableOpacity>
              )}
              ItemSeparatorComponent={() => <View style={styles.separator} />}
              contentContainerStyle={styles.optionsList}
            />
          </View>
        </View>
      </Modal>
    );
  };

  const renderDatePicker = () => {
    if (!showDatePicker && !showTimePicker) return null

    return (
      <DateTimePicker
        value={tempDateTime}
        mode={datePickerMode}
        is24Hour={true}
        display={Platform.OS === 'ios' ? 'spinner' : 'default'}
        onChange={onDateChange}
      />
    )
  }

  return (
    <View style={styles.container}>
      <StatusBar barStyle="dark-content" backgroundColor="#ffffff" />
      <Header />

      <View style={styles.headerContainer}>
        <View style={styles.titleRow}>
          <TouchableOpacity style={styles.backButton} onPress={() => navigation.goBack()}>
            <Icon name="arrow-back" size={24} color="#374151" />
          </TouchableOpacity>
          <View style={styles.titleContainer}>
            <Text style={styles.title}>Create {moduleName}</Text>
            <Text style={styles.subtitle}>New Record</Text>
          </View>
        </View>

        <TouchableOpacity
          style={[styles.createButton, saving && styles.createButtonDisabled]}
          onPress={handleCreate}
          disabled={saving}
        >
          {saving ? <ActivityIndicator size={20} color="#ffffff" /> : <Icon name="add" size={20} color="#ffffff" />}
          <Text style={styles.createButtonText}>{saving ? "Creating..." : "Create"}</Text>
        </TouchableOpacity>
      </View>

      {!loading && !error && fields.length > 0 && renderSearchBar()}

      <View style={styles.content}>{renderContent()}</View>

      {renderPicklistModal()}
      {renderDatePicker()}

      <Footer navigation={navigation} />
    </View>
  )
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: "#f8fafc",
  },
  headerContainer: {
    backgroundColor: "#ffffff",
    paddingHorizontal: 20,
    paddingVertical: 16,
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    borderBottomWidth: 1,
    borderBottomColor: "#e2e8f0",
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.05,
    shadowRadius: 4,
    elevation: 2,
  },
  titleRow: {
    flexDirection: "row",
    alignItems: "center",
    flex: 1,
  },
  backButton: {
    padding: 12,
    marginRight: 8,
    borderRadius: 12,
    backgroundColor: "#f1f5f9",
  },
  titleContainer: {
    flex: 1,
    marginLeft: 8,
  },
  title: {
    fontSize: 24,
    fontWeight: "700",
    color: "#1e293b",
    letterSpacing: -0.5,
  },
  subtitle: {
    fontSize: 14,
    color: "#64748b",
    marginTop: 2,
    fontWeight: "500",
  },
  createButton: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: "#10b981",
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 12,
    shadowColor: "#10b981",
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 4,
  },
  createButtonDisabled: {
    backgroundColor: "#94a3b8",
  },
  createButtonText: {
    color: "#ffffff",
    fontWeight: "600",
    marginLeft: 8,
    fontSize: 16,
  },
  content: {
    flex: 1,
  },
  scrollContent: {
    paddingBottom: 20,
  },
  statsContainer: {
    flexDirection: "row",
    paddingHorizontal: 20,
    paddingTop: 20,
    paddingBottom: 16,
    gap: 12,
  },
  statCard: {
    flex: 1,
    backgroundColor: "#ffffff",
    padding: 16,
    borderRadius: 16,
    alignItems: "center",
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.05,
    shadowRadius: 8,
    elevation: 2,
  },
  statNumber: {
    fontSize: 24,
    fontWeight: "700",
    color: "#6366f1",
  },
  statLabel: {
    fontSize: 12,
    color: "#64748b",
    marginTop: 4,
    fontWeight: "500",
  },
  fieldsContainer: {
    paddingHorizontal: 20,
    gap: 12,
  },
  fieldCard: {
    backgroundColor: "#ffffff",
    borderRadius: 16,
    padding: 20,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.05,
    shadowRadius: 8,
    elevation: 2,
    borderWidth: 1,
    borderColor: "#f1f5f9",
  },
  fieldCardError: {
    borderColor: "#fecaca",
    backgroundColor: "#fefefe",
  },
  fieldHeader: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 16,
  },
  fieldIconContainer: {
    width: 36,
    height: 36,
    borderRadius: 10,
    backgroundColor: "#f0f4ff",
    justifyContent: "center",
    alignItems: "center",
    marginRight: 12,
  },
  fieldInfo: {
    flex: 1,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  fieldLabel: {
    fontSize: 16,
    fontWeight: "600",
    color: "#374151",
    flex: 1,
  },
  requiredAsterisk: {
    color: "#ef4444",
    fontWeight: "700",
  },
  mandatoryBadge: {
    backgroundColor: "#fef3c7",
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: "#f59e0b",
  },
  mandatoryText: {
    fontSize: 10,
    fontWeight: "600",
    color: "#d97706",
    textTransform: "uppercase",
  },
  fieldInputContainer: {
    marginTop: 8,
  },
  input: {
    borderWidth: 1,
    borderColor: "#e2e8f0",
    borderRadius: 12,
    paddingHorizontal: 16,
    paddingVertical: 12,
    fontSize: 16,
    color: "#1e293b",
    backgroundColor: "#ffffff",
  },
  inputError: {
    borderColor: "#ef4444",
    backgroundColor: "#fef2f2",
  },
  textArea: {
    borderWidth: 1,
    borderColor: "#e2e8f0",
    borderRadius: 12,
    paddingHorizontal: 16,
    paddingVertical: 12,
    fontSize: 16,
    color: "#1e293b",
    backgroundColor: "#ffffff",
    minHeight: 100,
  },
  switchContainer: {
    flexDirection: "row",
    alignItems: "center",
    paddingVertical: 8,
  },
  switchLabel: {
    marginLeft: 12,
    fontSize: 16,
    color: "#374151",
    fontWeight: "500",
  },
  picklistButton: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    borderWidth: 1,
    borderColor: "#e2e8f0",
    borderRadius: 12,
    paddingHorizontal: 16,
    paddingVertical: 12,
    backgroundColor: "#ffffff",
  },
  picklistText: {
    fontSize: 16,
    color: "#1e293b",
    flex: 1,
  },
  placeholderText: {
    color: "#94a3b8",
  },
  errorContainer: {
    flexDirection: "row",
    alignItems: "center",
    marginTop: 8,
    paddingHorizontal: 4,
  },
  errorText: {
    fontSize: 14,
    color: "#ef4444",
    marginLeft: 6,
    flex: 1,
  },
  searchContainer: {
    paddingHorizontal: 20,
    paddingVertical: 16,
  },
  searchInputContainer: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: "#ffffff",
    borderRadius: 12,
    paddingHorizontal: 16,
    paddingVertical: 10,
    borderWidth: 1,
    borderColor: "#e2e8f0",
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.05,
    shadowRadius: 4,
    elevation: 2,
  },
  searchIcon: {
    marginRight: 12,
  },
  searchInput: {
    flex: 1,
    fontSize: 16,
    color: "#1e293b",
    fontWeight: "500",
  },
  clearButton: {
    padding: 4,
    marginLeft: 8,
  },
  searchResults: {
    fontSize: 14,
    color: "#64748b",
    marginTop: 8,
    fontWeight: "500",
  },
  loaderContainer: {
    flex: 1,
    justifyContent: "start",
    alignItems: "center",
    padding: 20,
  },
  loaderCard: {
    backgroundColor: "#ffffff",
    padding: 40,
    borderRadius: 20,
    alignItems: "center",
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 12,
    elevation: 4,
    width: width * 0.9,
  },
  loaderText: {
    marginTop: 20,
    fontSize: 18,
    fontWeight: "600",
    color: "#374151",
  },
  loaderSubtext: {
    marginTop: 8,
    fontSize: 14,
    color: "#64748b",
    textAlign: "center",
  },
  errorCard: {
    backgroundColor: "#ffffff",
    padding: 32,
    borderRadius: 20,
    alignItems: "center",
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 12,
    elevation: 4,
    width: width * 0.85,
  },
  errorIconContainer: {
    width: 80,
    height: 80,
    borderRadius: 40,
    backgroundColor: "#fef2f2",
    justifyContent: "center",
    alignItems: "center",
    marginBottom: 20,
  },
  errorTitle: {
    fontSize: 20,
    fontWeight: "700",
    color: "#374151",
    marginBottom: 8,
  },
  retryButton: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: "#ef4444",
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 12,
    shadowColor: "#ef4444",
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 4,
  },
  retryButtonText: {
    color: "#ffffff",
    fontWeight: "600",
    marginLeft: 8,
    fontSize: 16,
  },
  emptyStateContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 20,
  },
  emptyStateCard: {
    backgroundColor: "#ffffff",
    padding: 40,
    borderRadius: 20,
    alignItems: "center",
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 12,
    elevation: 4,
    width: width * 0.85,
  },
  emptyIconContainer: {
    width: 100,
    height: 100,
    borderRadius: 50,
    backgroundColor: "#f8fafc",
    justifyContent: "center",
    alignItems: "center",
    marginBottom: 24,
  },
  emptyStateTitle: {
    fontSize: 22,
    fontWeight: "700",
    color: "#374151",
    marginBottom: 12,
  },
  emptyStateText: {
    fontSize: 16,
    color: "#64748b",
    textAlign: "center",
    lineHeight: 24,
  },
  detailsContainer: {
    flex: 1,
  },
  noResultsContainer: {
    alignItems: "center",
    paddingVertical: 40,
    paddingHorizontal: 20,
  },
  noResultsTitle: {
    fontSize: 18,
    fontWeight: "600",
    color: "#374151",
    marginTop: 16,
    marginBottom: 8,
  },
  noResultsText: {
    fontSize: 14,
    color: "#64748b",
    textAlign: "center",
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.35)',
    justifyContent: 'flex-end',
  },
  modalContent: {
    backgroundColor: '#ffffff',
    borderTopLeftRadius: 24,
    borderTopRightRadius: 24,
    maxHeight: '80%',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: -4 },
    shadowOpacity: 0.1,
    shadowRadius: 12,
    elevation: 8,
  },
  modalHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#e2e8f0',
    backgroundColor: '#f8fafc',
    borderTopLeftRadius: 24,
    borderTopRightRadius: 24,
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: '700',
    color: '#1e293b',
    letterSpacing: -0.5,
  },
  modalCloseButton: {
    padding: 8,
    backgroundColor: '#f1f5f9',
    borderRadius: 12,
  },
  optionsList: {
    padding: 16,
  },
  optionItem: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: 16,
    borderRadius: 16,
    backgroundColor: '#ffffff',
    marginVertical: 4,
    borderWidth: 1,
    borderColor: '#e2e8f0',
  },
  selectedOption: {
    backgroundColor: '#f0f4ff',
    borderColor: '#6366f1',
  },
  optionText: {
    fontSize: 16,
    color: '#374151',
    flex: 1,
    fontWeight: '500',
  },
  selectedOptionText: {
    color: '#6366f1',
    fontWeight: '600',
  },
  separator: {
    height: 12,
  },
})

export default CreateScreen 